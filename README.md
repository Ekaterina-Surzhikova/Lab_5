# Суржикова Екатерина ИТ-14. Лабораторная №5 вариант 5
##1.1. Класс Дробь с интерфейсом и кэшированием

Алгоритм решения

Создан класс Fraction, реализующий интерфейс FractionInterface с кэшированием вещественного значения.

Класс Fraction:

Поля:

numerator - целочисленный числитель

denominator - целочисленный знаменатель

cachedDoubleValue - кэшированное вещественное значение

cacheValid - флаг валидности кэша

Конструкторы:

Fraction() - создает дробь 1/2

Fraction(int numerator, int denominator) - создает дробь с проверкой знаменателя

Основные методы:

getDoubleValue() - возвращает вещественное значение с кэшированием

setNumeratorAndDenominator() - устанавливает числитель и знаменатель через интерфейс

simplify() - упрощает дробь и корректирует знаки

gcd() - вычисляет НОД для упрощения

Особенности:

Автоматическое упрощение дробей при создании и изменении

Корректная обработка отрицательных значений (знаменатель всегда положительный)

Кэширование вещественного значения для оптимизации

Переопределенные equals() и hashCode() для сравнения по состоянию

Тестирование

=== ДЕМОНСТРАЦИЯ РАБОТЫ С ДРОБЯМИ ===

Дробь 1: 3/4 = 0.75

Дробь 2: 1/3 = 0.3333333333333333

Проверка кэширования:

Первое вычисление: 0.75

Второе вычисление: 0.75

##2.1. Количество мяуканий

Алгоритм решения

Реализован подсчет мяуканий через интерфейс Meowable без изменения класса Cat.

Класс Cat:

Поля:

name - имя кота

meowCount - счетчик мяуканий

Методы:

meow() - увеличивает счетчик и выводит сообщение

Геттеры для доступа к счетчику

Интерфейс Meowable:

meow() - метод для мяукающих объектов

Утилитный класс MeowUtils:

makeAllMeow() - вызывает мяуканье у всех объектов в списке

Особенности:

Кот не изменяется (требование задания)

Подсчет ведется внутри объекта кота

Возможность передачи одного кота несколько раз

Тестирование

=== ДЕМОНСТРАЦИЯ РАБОТЫ С КОТАМИ ===

Создан: кот: Барсик

До мяуканья: мяукнул 0 раз

Барсик: мяу!

Барсик: мяу!

После мяуканья: мяукнул 2 раз

##3.9. Симметрическая разность списков

Алгоритм решения

Реализован метод для нахождения элементов, которые есть только в одном из двух списков.

Класс ListUtils:

symmetricDifference() - возвращает симметрическую разность двух списков

Метод работы:

Преобразование списков в множества для удаления дубликатов

Поиск элементов, которые есть только в первом множестве

Поиск элементов, которые есть только во втором множестве

Объединение результатов

Тестирование

=== СИММЕТРИЧЕСКАЯ РАЗНОСТЬ СПИСКОВ ===

Список L1: [1, 2, 3, 4, 5]

Список L2: [4, 5, 6, 7, 8]

Симметрическая разность L: [1, 2, 3, 6, 7, 8]

##4.4. Обработка результатов тестирования абитуриентов

Алгоритм решения

Реализована фильтрация абитуриентов, не прошедших порог по баллам.

Класс Applicant:

Поля: фамилия, имя, баллы по двум предметам

Метод: isFailed() - проверяет, набрал ли абитуриент менее 30 баллов по любому предмету

Обработка:

Создание списка абитуриентов

Фильтрация через Stream API

Вывод неудавшихся абитуриентов

Тестирование

=== ОБРАБОТКА РЕЗУЛЬТАТОВ ТЕСТИРОВАНИЯ ===

Всего абитуриентов: 5

Не допущены к экзаменам:

Петров Иван (25, 45)

Сидорова Мария (35, 28)

Кузнецов Алексей (20, 25)

##5.5. Звонкие согласные в тексте

Алгоритм решения

Поиск звонких согласных, встречающихся более чем в одном слове.

Класс TextUtils:

findVoicedConsonants() - находит звонкие согласные по заданным условиям

Метод работы:

Разбиение текста на слова

Для каждого слова - сбор уникальных звонких согласных

Подсчет в скольких словах встречается каждая согласная

Фильтрация согласных, встречающихся более чем в одном слове

Сортировка в алфавитном порядке

Тестирование

=== АНАЛИЗ ТЕКСТА НА ЗВОНКИЕ СОГЛАСНЫЕ ===

Текст: Это пример текста на русском языке...

Звонкие согласные, входящие более чем в одно слово: [б, в, г, л, н, р]

##6.1. Обратный порядок очереди

Алгоритм решения

Вывод элементов очереди в обратном порядке без изменения самой очереди.

Класс QueueUtils:

printQueueReverse() - печатает элементы очереди в обратном порядке

Метод работы:

Создание временной копии очереди

Перенос элементов в стек (LIFO)

Последовательный вывод элементов из стека

Тестирование

=== РАБОТА С ОЧЕРЕДЬЮ ===

Исходная очередь: [1, 2, 3, 4, 5]

Очередь в обратном порядке: 5 4 3 2 1 

##7.1. Обработка точек через Stream API

Алгоритм решения

Создание ломаной линии из набора точек с преобразованиями через Stream API.

Классы:

Point - точка с координатами X, Y

Polyline - ломаная линия из массива точек

Преобразования в Stream:

distinct() - удаление точек с одинаковыми координатами

sorted() - сортировка по координате X

map() - преобразование отрицательных Y в положительные

collect() - сбор в объект Polyline

Тестирование

=== ОБРАБОТКА POINT ЧЕРЕЗ STREAM API ===

Исходные точки: [{1;2}, {3;4}, {1;2}, {5;-6}, {7;8}]

Результирующая ломаная: Линия [{1;2}, {3;4}, {5;6}, {7;8}]

##7.2. Обработка файла с именами и номерами

Алгоритм решения

Группировка людей по номерам с обработкой через Stream API.

Метод работы:

Чтение строк из файла

Разделение на имя и номер

Фильтрация записей без номеров

Нормализация имен (первая буква заглавная, остальные строчные)

Группировка по номерам

Тестирование

=== ОБРАБОТКА ФАЙЛА С ИМЕНАМИ И НОМЕРАМИ ===

Содержимое файла:

Вася:5

Петя:3

Аня:5

Маша:

Коля:3

Оля:7

Результат группировки:

3: [Петя, Коля]

5: [Вася, Аня]

7: [Оля]
